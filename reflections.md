✍️ Reflection (500 words)

Working on this capstone project, I set out to design and implement a simple web-based voting system using React. One of the main goals was not only to build a functional application but also to intentionally apply AI tools throughout the process. This reflection highlights how AI supported my development, the challenges I encountered, and the lessons I learned about prompting, reviewing, and iterating with AI.

From the very beginning, AI played a critical role in scaffolding the project. As a novice developer, setting up the initial structure of a React application and deciding how to organize components, API logic, and documentation can feel overwhelming. By prompting my AI assistant, I was able to scaffold the boilerplate quickly and focus on the actual logic of the voting system. AI suggested a folder structure, generated placeholder components like PollForm, VoteOptions, and Results, and even reminded me to separate my documentation in a /docs folder. This saved significant time and gave me a clear foundation.

During the implementation phase, AI was especially useful for generating code snippets and handling repetitive tasks. For example, when creating the poll and vote endpoints, I used AI to write basic fetch/axios clients. Similarly, I asked AI to produce unit tests for the core features. In both cases, the generated code was not always perfect, but it provided a strong starting point. This highlighted an important insight: AI can accelerate progress by reducing blank-page syndrome, but the developer still needs to review and adapt the output carefully.

One of the most valuable parts of using AI came during debugging and reviews. Instead of searching forums or documentation every time I faced an error, I prompted the AI with the exact error message and context. Often, it proposed fixes quickly, and even when the solutions were not perfect, they pointed me in the right direction. For reviews, I asked the AI to scan my code for redundant logic or unclear comments. It suggested simplifications, which improved readability and maintainability. This reinforced that AI is most effective as a “second pair of eyes,” not as an autopilot.

However, I also encountered limitations. At times, the AI generated code that was too advanced for my current understanding. While technically correct, it introduced patterns I was not familiar with, which slowed me down. In other cases, the AI provided solutions that looked plausible but failed when tested. This forced me to develop a healthy skepticism and validate outputs against my own understanding and test results. I learned that while AI is a great accelerator, it cannot replace deliberate practice, critical thinking, and testing.

Overall, this project deepened my appreciation for context-aware prompting. Being specific about what I wanted—such as “write a unit test for poll tallying logic using Jest”—produced far better results than vague prompts. I also realized the importance of iteration: rarely did the first AI output meet my needs fully, but refining prompts and combining my reasoning with AI suggestions created strong outcomes.

In conclusion, AI transformed my development process from slow and uncertain to structured and supported. It gave me scaffolding, testing help, debugging assistance, and documentation support. At the same time, I learned that the real power lies in collaboration: using AI as a guide, not a crutch. This project not only improved my technical skills but also taught me how to integrate AI into my workflow responsibly, critically, and creatively.
